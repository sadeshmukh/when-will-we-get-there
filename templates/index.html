<!DOCTYPE html>
<html>
  <head>
    <title>Progress Tracker</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Helvetica, Arial, sans-serif;
        background-color: #ffffff;
        color: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 50px;
        margin: 0;
      }
      .container {
        width: 90%;
        max-width: 800px;
        text-align: center;
      }
      h1 {
        font-weight: 400;
        margin-bottom: 1rem;
        font-size: 2rem;
      }
      .prediction {
        font-size: 1.2rem;
        color: #555;
        margin-bottom: 3rem;
      }
      canvas {
        width: 100% !important;
        height: auto !important;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>When Will We Get There?!</h1>
      <div style="margin-bottom: 1rem; font-size: 0.9rem">
        <a
          href="https://are-we-there-yet.hackclub.com"
          target="_blank"
          style="color: #888"
          >are-we-there-yet.hackclub.com</a
        >
      </div>
      <div class="prediction" id="prediction-text">Calculating...</div>

      <div style="margin-bottom: 20px">
        <label style="margin-right: 20px">
          <input type="checkbox" id="scaleToggle" /> Scale to Max Time
        </label>
        <label>
          <input type="checkbox" id="trendlineToggle" /> Show Trendline
        </label>
      </div>

      <canvas id="myChart"></canvas>
    </div>
    <script>
        const predictionTs = {{ prediction_ts | tojson }};
        const startTs = {{ start_ts | tojson }};
        const labels = {{ labels | tojson }};
        const values = {{ values | tojson }};

        // Format prediction text
      const predictionEl = document.getElementById('prediction-text');
      if (predictionTs) {
        const date = new Date(predictionTs * 1000);
        const now = new Date();
        const hoursRemaining = Math.round((date - now) / (1000 * 60 * 60));
        const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            predictionEl.textContent = "Predicted 100% at: " + date.toLocaleString() + " " + timeZone + " (in " + hoursRemaining + " hours)";
      } else {
        predictionEl.textContent = "Not enough data to predict.";
      }

      const ctx = document.getElementById('myChart').getContext('2d');
      const myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Percentage',
                    data: values,
                    borderColor: '#000000',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    fill: false,
                    tension: 0
                },
                {
                    label: 'Trendline',
                    data: [],
                    borderColor: '#ff6384',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                if (context.length > 0) {
                                    return new Date(context[0].parsed.x).toLocaleString();
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            stepSize: 30,
                            displayFormats: {
                                minute: 'h:mm'
                            }
                        },
                        ticks: {
                            stepSize: 30,
                            source: 'auto'
                        },
                        display: true,
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        beginAtZero: false,
                        grid: {
                            color: '#eeeeee'
                        }
                    }
                },
                interaction: {
                    mode: 'nearest',
                    axis: 'x',
                    intersect: false
                }
            }
        });

                // Trendline Logic
        const trendlineToggle = document.getElementById('trendlineToggle');
        function updateTrendline() {
            if (trendlineToggle.checked && labels.length > 1) {
                // Use only the last 60 points
                const subsetSize = 60;
                const startIndex = Math.max(0, labels.length - subsetSize);

                const subsetLabels = labels.slice(startIndex);
                const subsetValues = values.slice(startIndex);

                const n = subsetLabels.length;
                const refT = subsetLabels[0];

                let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

                for (let i = 0; i < n; i++) {
                    const x = subsetLabels[i] - refT;
                    const y = subsetValues[i];
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumXX += x * x;
                }

                const denominator = (n * sumXX - sumX * sumX);
                if (denominator === 0) return;

                const slope = (n * sumXY - sumX * sumY) / denominator;
                const intercept = (sumY - slope * sumX) / n;

                // Extend to full range
                let startX = labels[0];
                let endX = labels[labels.length - 1];

                // Check if scaled
                const scaleToggle = document.getElementById('scaleToggle');
                if (scaleToggle.checked && predictionTs) {
                    endX = predictionTs * 1000;
                }

                let startY = slope * (startX - refT) + intercept;
                let endY = slope * (endX - refT) + intercept;

                // Ensure we don't go below 0%
                if (startY < 0 && slope !== 0) {
                    startX = refT - intercept / slope;
                    startY = 0;
                }
                if (endY < 0 && slope !== 0) {
                    endX = refT - intercept / slope;
                    endY = 0;
                }

                myChart.data.datasets[1].data = [
                    {x: startX, y: startY},
                    {x: endX, y: endY}
                ];
            } else {
                myChart.data.datasets[1].data = [];
            }
            myChart.update();
        }
        trendlineToggle.addEventListener('change', updateTrendline);

        // Toggle Logic
        const scaleToggle = document.getElementById('scaleToggle');
        scaleToggle.addEventListener('change', (e) => {
          if (e.target.checked) {
            // Scale to 0-100% and Start-Predicted
            myChart.options.scales.y.min = 0;
            myChart.options.scales.y.max = 100;

            if (predictionTs) {
               const predictedDate = new Date(predictionTs * 1000);
               myChart.options.scales.x.max = predictedDate.valueOf();
            }

          } else {
            // Reset
            myChart.options.scales.y.min = undefined;
            myChart.options.scales.y.max = undefined;
            myChart.options.scales.x.max = undefined;
          }
          updateTrendline();
        });
    </script>
  </body>
</html>
