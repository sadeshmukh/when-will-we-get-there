<!DOCTYPE html>
<html>
  <head>
    <title>Progress Tracker</title>
    <style>
      :root {
        --bg-color: #0f172a;
        --text-color: #f8fafc;
        --link-color: #94a3b8;
        --prediction-color: #cbd5e1;
        --chart-line-color: #38bdf8;
        --chart-trend-color: #f472b6;
        --chart-grid-color: #334155;
        --chart-tick-color: #94a3b8;
      }

      .light-mode {
        --bg-color: #fdf6e3;
        --text-color: #000000;
        --link-color: #666666;
        --prediction-color: #555555;
        --chart-line-color: #000000;
        --chart-trend-color: #ff6384;
        --chart-grid-color: #dcdcdc;
        --chart-tick-color: #666666;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        padding-top: 50px;
        margin: 0;
        transition: background-color 0.3s, color 0.3s;
      }
      .container {
        width: 90%;
        max-width: 800px;
        text-align: center;
      }
      h1 {
        font-weight: 400;
        margin-bottom: 1rem;
        font-size: 2rem;
      }
      .prediction {
        font-size: 1.2rem;
        color: var(--prediction-color);
        margin-bottom: 3rem;
      }
      a {
        color: var(--link-color) !important;
      }
      canvas {
        width: 100% !important;
        height: auto !important;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>When Will We Get There?!</h1>
      <div style="margin-bottom: 1rem; font-size: 0.9rem">
        <a href="https://are-we-there-yet.hackclub.com" target="_blank"
          >Source</a
        >
        | <a href="/live">Live</a>
      </div>
      <div class="prediction" id="prediction-text">Calculating...</div>

      <div
        style="
          display: flex;
          flex-direction: column;
          width: 100%;
          margin-bottom: 20px;
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
          "
        >
          <div style="display: flex; gap: 15px">
            <label>
              <input type="checkbox" id="scaleToggle" /> Scale to Max Time
            </label>
            <label>
              <input type="checkbox" id="zoomLastHourToggle" /> Zoom Last Hour
            </label>
          </div>
          <label>
            <input type="checkbox" id="lightModeToggle" /> Light Mode
          </label>
        </div>

        <div
          style="
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 10px;
            gap: 20px;
          "
        >
          <div style="display: flex; align-items: center">
            <label
              for="modelSelect"
              style="margin-right: 10px; font-size: 0.9rem"
              >Model:</label
            >
            <select id="modelSelect" style="padding: 5px">
              <option value="linear">Linear (Standard)</option>
              <option value="exponential">Exponential</option>
              <option value="gompertz">Gompertz</option>
            </select>
          </div>

          <div style="display: flex; align-items: center">
            <label
              for="trendlineSlider"
              style="margin-right: 10px; font-size: 0.9rem"
            >
              Window:
              <span id="trendlineValue" style="font-weight: bold">60</span> min
            </label>
            <input
              type="range"
              id="trendlineSlider"
              min="10"
              step="5"
              value="60"
              style="width: 150px"
            />
          </div>
        </div>
      </div>

      <canvas id="myChart"></canvas>
    </div>
    <script>
      const predictionTs = {{ prediction_ts | tojson }};
      const startTs = {{ start_ts | tojson }};
      const labels = {{ labels | tojson }};
      const values = {{ values | tojson }};

      const predictionEl = document.getElementById('prediction-text');
      const trendlineSlider = document.getElementById('trendlineSlider');
      const trendlineValueDisplay = document.getElementById('trendlineValue');
      const scaleToggle = document.getElementById('scaleToggle');
      const zoomLastHourToggle = document.getElementById('zoomLastHourToggle');
      const lightModeToggle = document.getElementById('lightModeToggle');
      const modelSelect = document.getElementById('modelSelect');

      // Set max value for slider
      if (labels.length > 0) {
          const totalDurationMinutes = (labels[labels.length - 1] - labels[0]) / (1000 * 60);
          trendlineSlider.max = Math.min(120, Math.max(10, Math.floor(totalDurationMinutes)));
      }

      const ctx = document.getElementById('myChart').getContext('2d');

      // Get initial colors from CSS variables
      const computedStyle = getComputedStyle(document.body);

      const myChart = new Chart(ctx, {
          type: 'line',
          data: {
              labels: labels,
              datasets: [{
                  label: 'Percentage',
                  data: values,
                  borderColor: computedStyle.getPropertyValue('--chart-line-color').trim(),
                  borderWidth: 1.5,
                  pointRadius: 0,
                  pointHoverRadius: 4,
                  fill: false,
                  tension: 0
              },
              {
                  label: 'Trendline',
                  data: [],
                  borderColor: computedStyle.getPropertyValue('--chart-trend-color').trim(),
                  borderWidth: 2,
                  borderDash: [5, 5],
                  pointRadius: 0,
                  fill: false,
                  tension: 0
              }]
          },
          options: {
              responsive: true,
              plugins: {
                  legend: {
                      display: false
                  },
                  tooltip: {
                      mode: 'index',
                      intersect: false,
                      callbacks: {
                          title: function(context) {
                              if (context.length > 0) {
                                  const date = new Date(context[0].parsed.x);
                                  return date.toLocaleString(undefined, {
                                    weekday: 'short',
                                    month: 'short',
                                    day: 'numeric',
                                    hour: 'numeric',
                                    minute: '2-digit'
                                  });
                              }
                              return '';
                          },
                          label: function(context) {
                              let label = context.dataset.label || '';
                              if (label) {
                                  label += ': ';
                              }
                              if (context.parsed.y !== null) {
                                  label += context.parsed.y.toFixed(2);
                              }
                              return label;
                          }
                      }
                  }
              },
              scales: {
                  x: {
                      type: 'time',
                      time: {
                          unit: 'minute',
                          stepSize: 30,
                          displayFormats: {
                              minute: 'h:mm a'
                          }
                      },
                      ticks: {
                          stepSize: 30,
                          source: 'auto',
                          color: computedStyle.getPropertyValue('--chart-tick-color').trim()
                      },
                      display: true,
                      grid: {
                          display: false
                      }
                  },
                  y: {
                      beginAtZero: false,
                      grid: {
                          color: computedStyle.getPropertyValue('--chart-grid-color').trim()
                      },
                      ticks: {
                          color: computedStyle.getPropertyValue('--chart-tick-color').trim()
                      }
                  }
              },
              interaction: {
                  mode: 'nearest',
                  axis: 'x',
                  intersect: false
              }
          }
      });

      function calculateRegression(subsetLabels, subsetValues) {
           const n = subsetLabels.length;
           if (n < 2) return null;

           const refT = subsetLabels[0];
           let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;

           for (let i = 0; i < n; i++) {
               const x = subsetLabels[i] - refT;
               const y = subsetValues[i];
               sumX += x;
               sumY += y;
               sumXY += x * y;
               sumXX += x * x;
           }

           const denominator = (n * sumXX - sumX * sumX);
           if (denominator === 0) return null;

           const slope = (n * sumXY - sumX * sumY) / denominator;
           const intercept = (sumY - slope * sumX) / n;

           return { slope, intercept, refT };
      }

      function calculateExponentialRegression(subsetLabels, subsetValues) {
          // Fit y = 100 - A * e^(B * (x - refT))
          // ln(100 - y) = ln(A) + B * (x - refT)
          // Y = alpha + beta * X
          // Y = ln(100 - y), X = x - refT
          // A = exp(alpha), B = beta

          const n = subsetLabels.length;
          if (n < 2) return null;

          const refT = subsetLabels[0];
          let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
          let count = 0;

          for (let i = 0; i < n; i++) {
              const val = subsetValues[i];
              if (val >= 100) continue; // Cannot take log of <= 0

              const y = Math.log(100 - val);
              const x = subsetLabels[i] - refT;

              sumX += x;
              sumY += y;
              sumXY += x * y;
              sumXX += x * x;
              count++;
          }

          if (count < 2) return null;

          const denominator = (count * sumXX - sumX * sumX);
          if (denominator === 0) return null;

          const beta = (count * sumXY - sumX * sumY) / denominator;
          const alpha = (sumY - beta * sumX) / count;

          return { A: Math.exp(alpha), B: beta, refT };
      }

      function calculateGompertzRegression(subsetLabels, subsetValues) {
          // y = 100 * exp(-b * exp(-c * (x - refT)))
          // ln(y/100) = -b * exp(-c * (x - refT))
          // ln(-ln(y/100)) = ln(b) - c * (x - refT)
          // Y = A + B * X
          // Y = ln(-ln(y/100))
          // X = x - refT
          // B = -c  => c = -B
          // A = ln(b) => b = exp(A)

          const n = subsetLabels.length;
          if (n < 2) return null;

          const refT = subsetLabels[0];
          let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
          let count = 0;

          for (let i = 0; i < n; i++) {
              const val = subsetValues[i];
              if (val <= 0 || val >= 100) continue;

              const term1 = val / 100.0;
              const term2 = Math.log(term1); // negative
              const y = Math.log(-term2);    // ln(-ln(val/100))
              const x = subsetLabels[i] - refT;

              sumX += x;
              sumY += y;
              sumXY += x * y;
              sumXX += x * x;
              count++;
          }

          if (count < 2) return null;

          const denominator = (count * sumXX - sumX * sumX);
          if (denominator === 0) return null;

          const slope = (count * sumXY - sumX * sumY) / denominator;
          const intercept = (sumY - slope * sumX) / count;

          const c = -slope;
          const b = Math.exp(intercept);

          return { b, c, refT };
      }

      function updateTrendline() {
          const minutes = parseInt(trendlineSlider.value);
          trendlineValueDisplay.textContent = minutes;
          const model = modelSelect.value;

          if (labels.length < 2) {
              predictionEl.textContent = "Not enough data to predict.";
              return;
          }

          const lastTime = labels[labels.length - 1];
          const cutoffTime = lastTime - (minutes * 60 * 1000);

          const subsetLabels = [];
          const subsetValues = [];

          for(let i=0; i<labels.length; i++) {
              if (labels[i] >= cutoffTime) {
                  subsetLabels.push(labels[i]);
                  subsetValues.push(values[i]);
              }
          }

          let targetX = null;
          let trendData = [];

          if (model === 'linear') {
              const reg = calculateRegression(subsetLabels, subsetValues);
              if (reg && reg.slope > 0) {
                  targetX = ((100 - reg.intercept) / reg.slope) + reg.refT;

                  let startX = labels[0];
                  let endX = labels[labels.length - 1];
                  if (scaleToggle.checked) endX = targetX;

                  let startY = reg.slope * (startX - reg.refT) + reg.intercept;
                  let endY = reg.slope * (endX - reg.refT) + reg.intercept;

                  if (startY < 0) {
                      startX = -reg.intercept / reg.slope + reg.refT;
                      startY = 0;
                  }
                  trendData = [{x: startX, y: startY}, {x: endX, y: endY}];
              }
          } else if (model === 'exponential') {
              const reg = calculateExponentialRegression(subsetLabels, subsetValues);
              if (reg && reg.B < 0) {
                  // y = 100 - A * e^(B * (x - refT))
                  // Solve for y = 99 (effectively done)
                  // 99 = 100 - A * e^(B * t)
                  // -1 = -A * e^(B * t)
                  // 1/A = e^(B * t)
                  // ln(1/A) = B * t
                  // t = ln(1/A) / B

                  const tRel = Math.log(1.0 / reg.A) / reg.B;
                  targetX = tRel + reg.refT;

                  // Generate curve points
                  let startX = labels[0];
                  let endX = labels[labels.length - 1];
                  if (scaleToggle.checked && targetX) endX = targetX;

                  const steps = 50;
                  const stepSize = (endX - startX) / steps;

                  for (let i = 0; i <= steps; i++) {
                      const t = startX + i * stepSize;
                      const x = t - reg.refT;
                      const y = 100 - reg.A * Math.exp(reg.B * x);
                      if (y >= 0) {
                          trendData.push({x: t, y: y});
                      }
                  }
              }
          } else if (model === 'gompertz') {
              const reg = calculateGompertzRegression(subsetLabels, subsetValues);
              if (reg && reg.c > 0) {
                  // 99 = 100 * exp(-b * exp(-c * t))
                  // 0.99 = exp(-b * exp(-c * t))
                  // ln(0.99) = -b * exp(-c * t)
                  // -ln(0.99)/b = exp(-c * t)
                  // ln(-ln(0.99)/b) = -c * t
                  // t = -ln(-ln(0.99)/b) / c

                  const term = -Math.log(0.99) / reg.b;
                  if (term > 0) {
                      const tRel = -Math.log(term) / reg.c;
                      targetX = tRel + reg.refT;
                  }

                  // Generate curve points
                  let startX = labels[0];
                  let endX = labels[labels.length - 1];
                  if (scaleToggle.checked && targetX) endX = targetX;

                  const steps = 50;
                  const stepSize = (endX - startX) / steps;

                  for (let i = 0; i <= steps; i++) {
                      const t = startX + i * stepSize;
                      const x = t - reg.refT;
                      const y = 100 * Math.exp(-reg.b * Math.exp(-reg.c * x));
                      if (y >= 0) {
                          trendData.push({x: t, y: y});
                      }
                  }
              }
          }

          if (targetX) {
              const predictionDate = new Date(targetX);
              const now = new Date();

              const options = {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
              };
              const formattedDate = predictionDate.toLocaleString(undefined, options);

              const diffMs = predictionDate - now;
              const diffHrs = Math.floor(diffMs / (1000 * 60 * 60));
              const diffMins = Math.round((diffMs % (1000 * 60 * 60)) / (1000 * 60));

              let timeRemaining = "";
              if (diffHrs > 0) {
                  timeRemaining += `${diffHrs}h `;
              }
              timeRemaining += `${diffMins}m`;

              let prefix = "Predicted completion";
              if (model === 'exponential' || model === 'gompertz') prefix = "Predicted 99%";

              predictionEl.innerHTML = `${prefix}: <span style="color:var(--text-color); font-weight:bold">${formattedDate}</span> <span style="font-size:0.9em">(in ${timeRemaining})</span>`;
          } else {
              if (model === 'exponential') {
                   predictionEl.textContent = "Prediction: Not converging (rate is increasing or constant).";
              } else if (model === 'gompertz') {
                   predictionEl.textContent = "Prediction: Not converging (growth rate not decaying).";
              } else {
                   predictionEl.textContent = "Cannot predict completion.";
              }
          }

          myChart.data.datasets[1].data = trendData;

          // Update scale max if needed
          if (scaleToggle.checked) {
               myChart.options.scales.y.min = 0;
               myChart.options.scales.y.max = 100;
               if (targetX) {
                  myChart.options.scales.x.max = targetX;
               } else {
                  myChart.options.scales.x.max = undefined;
               }
          } else {
               myChart.options.scales.y.min = undefined;
               myChart.options.scales.y.max = undefined;
               myChart.options.scales.x.max = undefined;
          }

          // Zoom Last Hour Logic
          if (zoomLastHourToggle.checked) {
               const oneHourAgo = Date.now() - (60 * 60 * 1000);
               myChart.options.scales.x.min = oneHourAgo;
          } else {
               myChart.options.scales.x.min = undefined;
          }

          myChart.update();
      }      trendlineSlider.addEventListener('input', updateTrendline);
      modelSelect.addEventListener('change', updateTrendline);

      scaleToggle.addEventListener('change', (e) => {
        if (e.target.checked) {
          // Uncheck Zoom Last Hour if checked
          if (zoomLastHourToggle.checked) {
              zoomLastHourToggle.checked = false;
          }
        }
        updateTrendline();
      });

      zoomLastHourToggle.addEventListener('change', (e) => {
          if (e.target.checked) {
              // Uncheck Scale to Max Time if checked
              if (scaleToggle.checked) {
                  scaleToggle.checked = false;
              }
          }
          updateTrendline();
      });

      lightModeToggle.addEventListener('change', (e) => {
          if (e.target.checked) {
              document.body.classList.add('light-mode');
          } else {
              document.body.classList.remove('light-mode');
          }

          // Update Chart Colors
          const style = getComputedStyle(document.body);
          myChart.data.datasets[0].borderColor = style.getPropertyValue('--chart-line-color').trim();
          myChart.data.datasets[1].borderColor = style.getPropertyValue('--chart-trend-color').trim();
          myChart.options.scales.x.ticks.color = style.getPropertyValue('--chart-tick-color').trim();
          myChart.options.scales.y.ticks.color = style.getPropertyValue('--chart-tick-color').trim();
          myChart.options.scales.y.grid.color = style.getPropertyValue('--chart-grid-color').trim();

          myChart.update();
      });

      // Initial call
      updateTrendline();
    </script>
  </body>
</html>
